#!/bin/bash
# claude+ Project Chooser
# Pick from all projects with Claude Code sessions, or create a new one.
# Uses fzf for interactive selection and python3 for JSON parsing.
# Links and other updates here: https://larcombe.tech/blog/

set -euo pipefail

USER_PROJECTS_DIR="$HOME/projects"
CLAUDE_OUTPUT_LOG=$(mktemp /tmp/claude-session.XXXXXX)
trap "rm -f '$CLAUDE_OUTPUT_LOG'" EXIT

# Launch claude with automatic rate-limit retry.
# Uses `script` to transparently capture terminal output.
# After claude exits, checks for rate limit message. If found,
# parses the reset time, sleeps until then, and relaunches with --continue.
launch_claude() {
    local claude_args=("$@")

    local RATE_LIMIT_DEBUG="$HOME/.claude/rate-limit-debug.log"

    while true; do
        > "$CLAUDE_OUTPUT_LOG"  # clear previous capture
        local _script_exit=0

        # Background watcher: when Claude shows the rate-limit menu it waits for
        # interactive input and never exits. Detect "/rate-limit-options" in the log
        # and send Enter — option 1 ("Stop and wait") is pre-selected by default.
        local WATCHER_PID=""
        if [ -n "${TMUX_PANE:-}" ]; then
            local _pane="$TMUX_PANE"
            (
                while sleep 3; do
                    if tail -c 5000 "$CLAUDE_OUTPUT_LOG" 2>/dev/null | grep -q "rate-limit-options"; then
                        sleep 2  # let menu render fully before sending input
                        tmux send-keys -t "$_pane" "" Enter
                        break
                    fi
                done
            ) &
            WATCHER_PID=$!
        fi

        script -qfc "claude ${claude_args[*]}" "$CLAUDE_OUTPUT_LOG" || _script_exit=$?
        [ -n "$WATCHER_PID" ] && kill "$WATCHER_PID" 2>/dev/null || true

        # Strip ANSI/terminal codes using Python (handles UTF-8 middle dots, etc.)
        # strings(1) breaks on non-ASCII chars like the · separator in rate-limit messages
        local tail_output
        tail_output=$(tail -c 50000 "$CLAUDE_OUTPUT_LOG" | python3 -c "
import sys, re
data = sys.stdin.buffer.read()
data = re.sub(rb'\x1b\[[0-9;?]*[a-zA-Z]', b' ', data)   # CSI sequences
data = re.sub(rb'\x1b\][^\x07\x1b]*(?:\x07|\x1b\\\\)', b' ', data)  # OSC sequences
data = re.sub(rb'\x1b.', b' ', data)                     # other escapes
data = data.replace(b'\r', b'\n')                         # CR -> newline
data = re.sub(rb'[\x00-\x08\x0b-\x1f\x7f]', b' ', data) # strip control chars
text = data.decode('utf-8', errors='replace')
lines = [' '.join(l.split()) for l in text.split('\n') if l.strip()]
print('\n'.join(lines[-500:]))
")

        # Debug log: save rate-limit-related lines for post-mortem
        {
            echo "=== $(date) === (exit code: $_script_exit) ==="
            echo "$tail_output" | grep -i "limit\|resets\|hit\|usage" || echo "(no match)"
        } >> "$RATE_LIMIT_DEBUG" 2>/dev/null

        # Detect rate limit: matches "hit your limit", "fast limit reached", etc.
        if echo "$tail_output" | grep -qi "hit your.*limit\|fast limit reached\|out of extra usage\|usage limit\|rate.limit\|limit reached"; then
            local reset_line
            reset_line=$(echo "$tail_output" | grep -i "resets" | tail -1)

            local sleep_secs
            sleep_secs=$(python3 << PYEOF
import re, sys
from datetime import datetime, timedelta
import zoneinfo

line = '''$reset_line'''

# "resets in Xh Ym" format (fast mode / cooldown)
m = re.search(r'resets in\s+(?:(\d+)h\s*)?(?:(\d+)m)?', line, re.IGNORECASE)
if m and (m.group(1) or m.group(2)):
    h = int(m.group(1) or 0)
    mins = int(m.group(2) or 0)
    print(max(h * 3600 + mins * 60 + 60, 60))
    sys.exit()

# "resets 11pm (America/New_York)" format (regular limit)
match = re.search(r'resets\s+(\d{1,2}(?::\d{2})?\s*[ap]m)\s*\(([^)]+)\)', line, re.IGNORECASE)
if not match:
    print(300)
    sys.exit()

time_str = match.group(1).strip().upper().replace(' ', '')
tz_str = match.group(2).strip()

try:
    tz = zoneinfo.ZoneInfo(tz_str)
except Exception:
    tz = zoneinfo.ZoneInfo('UTC')

now = datetime.now(tz)
parsed = None
for fmt in ['%I:%M%p', '%I%p']:
    try:
        parsed = datetime.strptime(time_str, fmt)
        break
    except ValueError:
        continue

if not parsed:
    print(300)
    sys.exit()

reset = now.replace(hour=parsed.hour, minute=parsed.minute, second=0, microsecond=0)
if reset <= now:
    reset += timedelta(days=1)

diff = int((reset - now).total_seconds()) + 60
print(max(diff, 60))
PYEOF
)
            local mins=$((sleep_secs / 60))
            local reset_desc
            if echo "$reset_line" | grep -qi "resets in"; then
                reset_desc=$(echo "$reset_line" | grep -oiP 'resets in [\dhm ]+' | head -1)
            else
                reset_desc=$(echo "$reset_line" | grep -oP 'resets\s+\K[^(]+' | sed 's/ *$//')
            fi

            echo ""
            echo "══════════════════════════════════════════════════════"
            echo "  Rate limit hit. Auto-resuming in ~${mins} minutes"
            echo "  (${reset_desc:-unknown reset time})"
            echo "  Press Ctrl-C to cancel"
            echo "══════════════════════════════════════════════════════"
            echo ""

            sleep "$sleep_secs"

            echo "Resuming session..."
            claude_args=(--dangerously-skip-permissions --continue)
        else
            break
        fi
    done
}

# Encode a filesystem path to the Claude session directory name format.
# Claude replaces every non-alphanumeric character with a hyphen.
encode_path() {
    echo "$1" | python3 -c "import sys, re; print(re.sub(r'[^a-zA-Z0-9]', '-', sys.stdin.read().strip()))"
}

# Find all session dirs in ~/.claude/projects that belong to a given project path.
# Checks both the current bind-mount path and the old /mnt/raid0 path (pre-bind-mount).
find_session_dirs() {
    local path="$1"
    local cp="$HOME/.claude/projects"

    local enc
    enc=$(encode_path "$path")
    [ -d "$cp/$enc" ] && echo "$cp/$enc"

    # Also check old NAS-path encoding (sessions created before bind-mounts were set up)
    local nas_path="${path/$HOME\/projects//mnt/raid0/projects}"
    if [ "$nas_path" != "$path" ]; then
        local nas_enc
        nas_enc=$(encode_path "$nas_path")
        [ "$nas_enc" != "$enc" ] && [ -d "$cp/$nas_enc" ] && echo "$cp/$nas_enc"
    fi
}

# Archive a project: move it and its session data to the NAS backup area.
archive_project() {
    local path="$1"
    local name
    name=$(basename "$path")
    local archive_dir="/mnt/raid0/backups/projects"

    echo ""
    echo "  Archive: $name"
    echo "  From:    $path"
    echo "  To:      $archive_dir/$name"
    echo ""
    echo -n "  Confirm? [y/N] "
    read -r confirm
    echo ""
    [[ "$confirm" =~ ^[Yy]$ ]] || { echo "  Cancelled."; return 1; }

    mkdir -p "$archive_dir" || { echo "  Cannot create $archive_dir (NAS accessible?)" >&2; return 1; }
    mv "$path" "$archive_dir/$name" || { echo "  Failed to move project." >&2; return 1; }
    echo "  Project moved."

    local archive_sessions="/mnt/raid0/backups/claude-sessions"
    mkdir -p "$archive_sessions"
    while IFS= read -r sd; do
        [ -z "$sd" ] && continue
        mv "$sd" "$archive_sessions/$(basename "$sd")" 2>/dev/null \
            && echo "  Session data archived: $(basename "$sd")" || true
    done < <(find_session_dirs "$path")

    echo "  Done."
}

# Delete a project: remove directory, session data, and optionally the GitHub repo.
delete_project() {
    local path="$1"
    local name
    name=$(basename "$path")

    # Detect GitHub remote before we delete the directory
    local github_repo=""
    if [ -d "$path/.git" ]; then
        github_repo=$(cd "$path" && git remote get-url origin 2>/dev/null \
            | sed -nE 's|.*github\.com[/:]([^/]+/[^/]+?)(\.git)?$|\1|p' || true)
    fi

    echo ""
    echo "  DELETE: $name"
    [ -n "$github_repo" ] && echo "  GitHub: github.com/$github_repo"
    echo ""
    echo -n "  Type project name to confirm: "
    read -r confirm
    echo ""
    [ "$confirm" = "$name" ] || { echo "  Name mismatch, cancelled."; return 1; }

    while IFS= read -r sd; do
        [ -z "$sd" ] && continue
        rm -rf "$sd"
        echo "  Session data deleted: $(basename "$sd")"
    done < <(find_session_dirs "$path")

    rm -rf "$path"
    echo "  Project directory deleted."

    if [ -n "$github_repo" ] && command -v gh &>/dev/null; then
        echo -n "  Delete GitHub repo $github_repo? [y/N] "
        read -r del_gh
        echo ""
        if [[ "$del_gh" =~ ^[Yy]$ ]]; then
            gh repo delete "$github_repo" --yes \
                && echo "  GitHub repo deleted." \
                || echo "  Failed to delete GitHub repo (check: gh auth status)."
        fi
    fi

    echo "  Done."
}

# Build the project list using python3
build_project_list() {
    python3 << 'PYEOF'
import json
import os
import glob
from datetime import datetime, timezone
claude_projects_dir = os.path.expanduser("~/.claude/projects")
user_projects_dir = os.path.expanduser("~/projects")

def relative_date(iso_str):
    if not iso_str:
        return "?"
    try:
        dt = datetime.fromisoformat(iso_str.replace('Z', '+00:00'))
        now = datetime.now(timezone.utc)
        secs = int((now - dt).total_seconds())
        if secs < 60:      return "just now"
        if secs < 3600:    return f"{secs//60}m ago"
        if secs < 86400:   return f"{secs//3600}h ago"
        if secs < 172800:  return "yesterday"
        if secs < 604800:  return f"{secs//86400}d ago"
        if secs < 2592000: return f"{secs//604800}w ago"
        return iso_str[:10]
    except Exception:
        return iso_str[:10] if iso_str else "?"

projects = {}  # path -> {sessions, last_modified, summary}

# Scan ~/.claude/projects/ for session data
if os.path.isdir(claude_projects_dir):
    for entry in os.scandir(claude_projects_dir):
        if not entry.is_dir():
            continue

        real_path = None
        sessions = 0
        last_modified = None
        summary = ""

        index_file = os.path.join(entry.path, "sessions-index.json")
        if os.path.isfile(index_file):
            try:
                with open(index_file) as f:
                    data = json.load(f)
                real_path = data.get("originalPath")
                entries = data.get("entries", [])
                sessions = len(entries)
                # Find most recent entry
                latest = None
                for e in entries:
                    mod = e.get("modified")
                    if mod and (latest is None or mod > latest.get("modified", "")):
                        latest = e
                if latest:
                    last_modified = latest.get("modified", "")
                    s = latest.get("summary", "")
                    if s and s != "User Exited Claude Code CLI Session":
                        summary = s
            except (json.JSONDecodeError, OSError):
                pass

        # Also count jsonl files (may have more than what's in the index)
        jsonl_files = glob.glob(os.path.join(entry.path, "*.jsonl"))
        if not sessions:
            sessions = len(jsonl_files)

        # If no real_path from index, try to get it from jsonl cwd field
        if not real_path and jsonl_files:
            # Try each jsonl (newest first) until we find a cwd
            for jsonl_file in sorted(jsonl_files, key=os.path.getmtime, reverse=True):
                try:
                    with open(jsonl_file) as f:
                        for i, line in enumerate(f):
                            if i > 5:
                                break
                            try:
                                d = json.loads(line)
                                if d.get("cwd"):
                                    real_path = d["cwd"]
                                    break
                            except json.JSONDecodeError:
                                continue
                except OSError:
                    continue
                if real_path:
                    break

        # If still no real_path, skip this entry
        if not real_path:
            continue

        # Get last_modified from jsonl file mtime, always comparing against index value.
        # sessions-index.json can be stale (not updated by Claude on every session),
        # so we take whichever is newer: the index date or the actual file mtime.
        if jsonl_files:
            newest_mtime = max(os.path.getmtime(f) for f in jsonl_files)
            file_modified = datetime.fromtimestamp(newest_mtime, tz=timezone.utc).isoformat()
            if not last_modified or file_modified > last_modified:
                last_modified = file_modified

        # If no summary from index, try to get firstPrompt or summary from jsonl
        if not summary and jsonl_files:
            newest_jsonl = max(jsonl_files, key=os.path.getmtime)
            try:
                with open(newest_jsonl) as f:
                    for i, line in enumerate(f):
                        if i > 30:
                            break
                        try:
                            d = json.loads(line)
                            if d.get("type") == "summary" and d.get("summary"):
                                summary = d["summary"]
                                break
                        except json.JSONDecodeError:
                            continue
            except OSError:
                pass

        if sessions > 0:
            projects[real_path] = {
                "sessions": sessions,
                "last_modified": last_modified or "",
                "summary": summary,
            }

# Scan ~/projects/ for directories that don't have sessions yet
if os.path.isdir(user_projects_dir):
    for entry in os.scandir(user_projects_dir):
        if entry.is_dir() and entry.path not in projects:
            projects[entry.path] = {
                "sessions": 0,
                "last_modified": "",
                "summary": "",
            }

# Sort: projects with sessions first (by last_modified desc), then sessionless alphabetically
with_sessions = []
without_sessions = []

for path, info in projects.items():
    if info["sessions"] > 0:
        with_sessions.append((path, info))
    else:
        without_sessions.append((path, info))

with_sessions.sort(key=lambda x: x[1]["last_modified"], reverse=True)
without_sessions.sort(key=lambda x: os.path.basename(x[0]).lower())

# Output format: HAS_SESSIONS:PATH\tDISPLAY_LINE
# HAS_SESSIONS is 1 or 0, used to decide --continue flag
# PATH is hidden from fzf (--with-nth=2 shows only after the tab)

for path, info in with_sessions:
    name = os.path.basename(path)
    date_str = relative_date(info["last_modified"])
    summary_text = info["summary"][:58].replace("\n", " ") if info["summary"] else ""
    sess = info["sessions"]
    sess_word = "session" if sess == 1 else "sessions"
    # ● name  · N sessions · date · summary
    line = (f"\033[32m●\033[0m \033[1;36m{name}\033[0m"
            f"  \033[2m·\033[0m \033[33m{sess} {sess_word}\033[0m"
            f" \033[2m· {date_str}\033[0m")
    if summary_text:
        line += f"  \033[2m{summary_text}\033[0m"
    print(f"1:{path}\t{line}")

for path, info in without_sessions:
    name = os.path.basename(path)
    line = f"\033[2m○ {name}\033[0m"
    print(f"0:{path}\t{line}")
PYEOF
}

# Main
main() {
    # Run inside a named tmux session so it can be attached from anywhere.
    # Skip if already inside tmux (TMUX is set) or if we were launched by tmux
    # (CLAUDE_IN_TMUX is set, preventing infinite re-launch).
    if [ -z "${TMUX:-}" ] && [ -z "${CLAUDE_IN_TMUX:-}" ]; then
        if tmux has-session -t "claude+" 2>/dev/null; then
            exec tmux attach-session -t "claude+"
        else
            exec tmux new-session -s "claude+" -e "CLAUDE_IN_TMUX=1" "claude+"
        fi
    fi

    if ! command -v fzf &>/dev/null; then
        echo "Error: fzf is required. Install with: sudo pacman -S fzf" >&2
        exit 1
    fi

    # Loop: show picker, launch project, return here on /exit.
    # Esc/Ctrl-C in fzf breaks the loop and exits the tmux session.
    clear
    while true; do
        local project_list
        project_list=$(build_project_list)

        if [ -z "$project_list" ]; then
            echo "No projects found." >&2
            exit 1
        fi

        local new_project_line=$'\t\033[1;32m✦  NEW PROJECT\033[0m'
        local no_project_line=$'NOPROJ:\t\033[33m◈  NO PROJECT \033[2m(no git)\033[0m'
        local full_list="${new_project_line}"$'\n'"${no_project_line}"$'\n'"${project_list}"

        # Run fzf — --expect captures Ctrl-A/X without opening the project.
        # Output: line 1 = key pressed ("" for Enter), line 2 = selected item.
        local raw_selection
        raw_selection=$(echo -e "$full_list" | fzf \
            --ansi \
            --delimiter='\t' \
            --with-nth=2 \
            --header=$'Enter: open  Ctrl-A: archive  Ctrl-X: delete  Ctrl-/: preview  Esc: quit' \
            --header-first \
            --no-sort \
            --reverse \
            --height=100% \
            --border=rounded \
            --prompt="  " \
            --pointer="▶" \
            --marker="✓" \
            --color='bg+:#313244,hl:#89b4fa,hl+:#89b4fa,pointer:#f38ba8,prompt:#cba6f7,marker:#a6e3a1,header:#89dceb,border:#585b70' \
            --expect=ctrl-a,ctrl-x \
            --preview='~/.local/bin/claude-project-preview {1}' \
            --preview-window='right:45%:wrap:border-left:hidden' \
            --bind='ctrl-/:toggle-preview' \
        ) || break  # Esc/Ctrl-C exits the loop cleanly

        local pressed_key
        pressed_key=$(echo "$raw_selection" | head -1)
        local selection
        selection=$(echo "$raw_selection" | tail -n +2)

        # Extract the path — format is "HAS_SESSIONS:PATH\tDISPLAY"
        local selected_field
        selected_field=$(echo "$selection" | cut -f1)
        local selected_path="${selected_field#*:}"
        local has_sessions_flag="${selected_field%%:*}"

        # Handle archive / delete — continue to refresh the picker
        if [ "$pressed_key" = "ctrl-a" ]; then
            if [ -z "$selected_path" ] || [ "$has_sessions_flag" = "NOPROJ" ]; then
                echo "  Select a real project to archive." >&2; sleep 1
            elif [ ! -d "$selected_path" ]; then
                echo "  Directory not found: $selected_path" >&2; sleep 1
            else
                archive_project "$selected_path" || true
                sleep 1
            fi
            continue
        fi

        if [ "$pressed_key" = "ctrl-x" ]; then
            if [ -z "$selected_path" ] || [ "$has_sessions_flag" = "NOPROJ" ]; then
                echo "  Select a real project to delete." >&2; sleep 1
            else
                delete_project "$selected_path" || true
                sleep 1
            fi
            continue
        fi

        # Handle "~ NO PROJECT"
        if [ "$has_sessions_flag" = "NOPROJ" ]; then
            echo "Starting Claude without a project..."
            launch_claude --dangerously-skip-permissions || true
            continue
        fi

        # Handle "+ NEW PROJECT" (empty path)
        if [ -z "$selected_path" ]; then
            echo -n "New project name: "
            read -r project_name
            if [ -z "$project_name" ]; then
                continue
            fi

            local new_dir="$USER_PROJECTS_DIR/$project_name"
            if [ -d "$new_dir" ]; then
                echo "Directory already exists: $new_dir" >&2
                echo "Launching Claude in existing directory..."
                cd "$new_dir"
                launch_claude --dangerously-skip-permissions || true
                continue
            fi

            mkdir -p "$new_dir"
            cd "$new_dir"
            git init
            touch CLAUDE.md
            echo "Created project: $new_dir"
            launch_claude --dangerously-skip-permissions || true
            continue
        fi

        # Handle existing project
        if [ ! -d "$selected_path" ]; then
            echo "Directory no longer exists: $selected_path" >&2
            sleep 1
            continue
        fi

        cd "$selected_path"

        if [ "$has_sessions_flag" = "1" ]; then
            echo "Resuming in: $selected_path"
            launch_claude --dangerously-skip-permissions --continue || true
        else
            echo "Starting new session in: $selected_path"
            launch_claude --dangerously-skip-permissions || true
        fi
        clear
        # Loop continues — picker shown again after claude exits
    done
}

main "$@"
